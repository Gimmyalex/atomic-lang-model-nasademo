# Atomic Language Model: Formal Specification

## Overview

This specification defines an extremely lightweight (< 50kB binary) universal grammar-based language model implementing the recursive principles of Minimalist Grammar theory with provable mathematical properties.

## 1. Core Objects

### 1.1 Feature System

**Feature String Definition:**
```
f₁...fₖ where fᵢ ∈ {CAT, =CAT, +f, -f}
```

**Feature Types:**
- **Category features (CAT)**: Basic syntactic categories (N, V, D, etc.)
- **Selector features (=CAT)**: Require merging with specific category
- **Positive features (+f)**: Trigger movement operations
- **Negative features (-f)**: Target for movement operations

### 1.2 Lexical Items

**Structure:**
```rust
struct LexItem {
    phon: String,           // Phonological form
    feats: Vec<Feature>,    // Feature bundle
}
```

**Example:**
```rust
li("the", &[D])
li("student", &[N])
li("who", &[C, =S])
li("said", &[=DP, V, +wh])
```

### 1.3 Syntactic Objects

**Structure:**
```rust
struct SyntacticObject {
    label: Category,
    features: Vec<Feature>,
    children: Vec<SyntacticObject>,
}
```

## 2. Operations (Stabler 1997)

### 2.1 Merge Operation

**Definition:**
```
Merge(α:=ₓβ, X:γ) = ⟨X, [], [α, γ]⟩
```

**Conditions:**
1. First argument has selector feature =X
2. Second argument has category feature X
3. Result: New object with label X, empty features, children [α, γ]

**Rust Implementation:**
```rust
fn merge(a: Obj, b: Obj) -> Option<Obj> {
    match (&a.features[0], &b.features[0]) {
        (Feature::Sel(cat1), Feature::Cat(cat2)) if cat1 == cat2 => {
            Some(Obj {
                label: cat2.clone(),
                features: vec![],
                children: vec![a, b],
            })
        }
        _ => None,
    }
}
```

### 2.2 Move Operation

**Definition:**
```
Move(α[+f], ...β[-f]...) = ⟨label(α), [], [MoveTarget(β), ...]⟩
```

**Conditions:**
1. Root has positive feature +f
2. Some constituent has matching negative feature -f
3. Result: Extract -f constituent to edge position

**Rust Implementation:**
```rust
fn move_f(obj: Obj) -> Option<Obj> {
    if let Some(pos_feat) = obj.features.iter().find(|f| f.is_positive()) {
        // Find matching negative feature in embedded constituents
        if let Some(target) = find_negative_target(&obj, pos_feat) {
            Some(extract_and_adjoin(obj, target))
        } else {
            None
        }
    } else {
        None
    }
}
```

## 3. Derivation System

### 3.1 Workspace Management

**Structure:**
```rust
struct Workspace {
    items: Vec<SyntacticObject>,
    memory_limit: usize,
}
```

**Operations:**
```rust
fn step(workspace: &mut Workspace) -> Result<(), DerivationError> {
    // Try merge operations first
    if let Some((i, j)) = find_mergeable_pair(&workspace.items) {
        let merged = merge(workspace.items[i].clone(), workspace.items[j].clone())?;
        workspace.replace_pair(i, j, merged);
        return Ok(());
    }
    
    // Try move operations
    if let Some(i) = find_moveable_item(&workspace.items) {
        let moved = move_f(workspace.items[i].clone())?;
        workspace.items[i] = moved;
        return Ok(());
    }
    
    Err(DerivationError::NoValidOperations)
}
```

### 3.2 Halting Condition

**Success Condition:**
A derivation succeeds if and only if:
1. Workspace contains exactly one syntactic object
2. All features in the object are empty (checked features)
3. The object has a valid category label

```rust
fn is_successful_derivation(workspace: &Workspace) -> bool {
    workspace.items.len() == 1 && 
    workspace.items[0].features.is_empty() &&
    workspace.items[0].label.is_valid()
}
```

## 4. Formal Properties

### 4.1 Generative Capacity

**Theorem 1 (Stabler 1997):** 
The class of languages generated by Minimalist Grammars is exactly the class of Multiple Context-Free Languages (MCFLs).

**Proof Sketch:**
1. Every MG derivation can be simulated by an MCFG
2. Every MCFG can be encoded as an MG
3. Both directions preserve the language recognized

### 4.2 Complexity Properties

**Time Complexity:** Polynomial in sentence length
**Space Complexity:** Linear in maximum embedding depth
**Recursion Depth:** Unbounded (constrained only by available memory)

## 5. Recursive Properties

### 5.1 Center-Embedding

**Grammar Fragment:**
```rust
static RECURSIVE_GRAMMAR: &[LexItem] = &[
    li("the", &[D]),
    li("student", &[N]),
    li("tutor", &[N]),
    li("who", &[C, =S]),
    li("said", &[=DP, V, +wh]),
    li("left", &[V]),
];

static RULES: &[Rule] = &[
    rule("S", &["NP", "VP"]),
    rule("NP", &["D", "N"]),
    rule("NP", &["NP", "CP"]),  // Recursive rule
    rule("CP", &["C", "S"]),
    rule("VP", &["V", "NP"]),
    rule("VP", &["V"]),
];
```

### 5.2 Formal Language Tests

**aⁿbⁿ Generation:**
```rust
fn generate_center_embedding(n: usize) -> String {
    let a_part = "a ".repeat(n);
    let b_part = "b ".repeat(n);
    format!("{}{}", a_part, b_part).trim().to_string()
}

#[test]
fn test_recursive_generation() {
    for n in 0..=5 {
        let string = generate_center_embedding(n);
        assert!(can_parse(&string), "Failed to parse a^{}b^{}", n, n);
    }
}
```

## 6. Memory and Size Constraints

### 6.1 Binary Size Targets

| Component | Target Size | Implementation |
|-----------|-------------|----------------|
| Grammar Engine | < 35 kB | Rust no_std, size optimization |
| Feature System | < 5 kB | Compact enum representations |
| Parser Core | < 15 kB | Stack-based Earley parser |
| Lexicon | < 10 kB | Static arrays, no allocation |

### 6.2 Runtime Memory

**Maximum Memory Usage:**
- Peak RAM during 20-word sentence: < 256 kB
- Stack depth for center-embedding: O(log n)
- Workspace size: Bounded by sentence length

### 6.3 Compilation Settings

```toml
[profile.release]
opt-level = "z"  # Optimize for size
lto = true       # Link-time optimization
codegen-units = 1
panic = "abort"
strip = true

[dependencies]
# Zero runtime dependencies for no_std build
```

## 7. Testing and Verification

### 7.1 Recursion Tests

**Required Test Cases:**
1. aⁿbⁿ generation for n = 0..9
2. Nested relative clause parsing
3. DFA simulation showing exponential state growth
4. Memory usage profiling during deep embedding

### 7.2 Linguistic Evaluation

**Agreement Test Suite (Linzen 2016):**
- Subject-verb agreement across intervening material
- Performance metric: Accuracy = correct / (correct + incorrect)

**Colorless Green Test Suite (Gulordava 2018):**
- Complexity penalty: ΔS = (1/N) Σᵢ [length(dᵢ) - length(gᵢ)]
- Tests syntactic processing independent of semantics

## 8. Mathematical Foundations

### 8.1 Non-Regularity Proof

**Runtime Verification:**
For each n, generate aⁿbⁿ and simulate DFA recognition:
- If regular, DFA states should remain bounded
- Actual behavior: exponential growth in state count
- Constructive proof of non-regularity at runtime

### 8.2 Minimalist Grammar Formalization

**Context-Free Approximation:**
```
S → aSb | ε
NP → NP CP | Det N  
CP → C S
```

**Minimalist Encoding:**
```rust
impl MergeRule for Grammar {
    fn apply_merge(&self, workspace: &mut Workspace) -> Result<(), Error> {
        // Implement Merge(α, β) = {α, β} with feature checking
    }
}
```

This specification provides the mathematical foundation for implementing a provably recursive, extremely lightweight language model that demonstrates universal grammar principles in under 50kB of compiled code.